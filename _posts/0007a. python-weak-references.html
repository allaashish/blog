---
categories: Programming
date: 2008/04/30 22:41:25
permalink: http://mindtrove.info/python-weak-references/
tags: python
title: Python Weak References
---
<p>The <a href="http://docs.python.org/lib/module-weakref.html">weakref module</a> in the Python standard library is a useful tool for creating Python references without impeding object destruction. This tutorial covers the basics of weak references, and introduces a <tt>Proxy</tt> class enabling weak references to method objects.</p>

<h2>Hefty, hefty, hefty</h2>

<p><em>Strong references</em> are pointers to objects that have an effect on their reference counts, and hence their lifetime and destruction. Strong references are what you see all the time when you assign an object to a variable:</p>

$$code(lang=pycon)
>>> a = [1,2,3]
>>> b = a
$$/code

<p>In this case, the list object has two strong references to it stored in a and b. The list will not be destroyed until both references are released:</p>

$$code(lang=python)
>>> del a
>>> del b
$$/code

<p>In this case, it is hard to tell exactly when the list object is destroyed. A class with a verbose __del__ method provides a better example:</p>

$$code(lang=python)
class Foo(object):
     def __init__(self):
       self.obj = None
       print 'created'  

     def __del__(self):
         print 'destroyed'

     def show(self):
         print self.obj

     def store(self, obj):
         self.obj = obj
$$/code

<p>Again, if we create two strong references to a single instance of Foo, we can now see that it is not destroyed until both references are discarded:</p>

$$code(lang=pycon)
>>> a = Foo()
created
>>> b = a
>>> del a
>>> del b
destroyed
$$/code

<h2>Wimpy, wimpy, wimpy</h2>

<p><em>Weak references</em>, on the other hand, have no effect on the reference count for an object. The existence of a weak reference never impedes object destruction. That is, if an object has only weak references, it will be destroyed.</p>

<p>To create a weak reference to an object, you use the weakref.ref function. The call requires a strong reference to an object as the first parameter and returns a weak reference to that object:</p>

$$code(lang=pycon)
import weakref
>>> a = Foo()
created
>>> b = weakref.ref(a)
$$/code

<p>A temporary strong reference can be created from a weak reference by calling it:</p>

$$code(lang=pycon)
>>> a == b()
True
>>> b().show()
None
$$/code

<p>Notice that when we delete the one and only strong reference to our Foo object, it is immediately destroyed:</p>

$$code(lang=pycon)
>>> del a
destroyed
$$/code

<p>If we try to call our weak reference after the object has been destroyed, we get None in its place:</p>

$$code(lang=pycon)
>>> b() is None
True
$$/code

<p>As a more transparent alternative to weakref.ref, we can use weakref.proxy. This call requires a strong reference to an object as its first argument and returns a weak reference proxy. The proxy behaves just like a strong reference, but throws an exception when used after the target is dead:</p>

$$code(lang=pycon)
>>> a = Foo()
created
>>> b = weakref.proxy(a)
>>> b.store('fish')
>>> b.show()
fish
>>> del a
destroyed
>>> b.show()
Traceback (most recent call last):
  File "", line 1, in ?
ReferenceError: weakly-referenced object no longer exists
$$/code

<h2>Cyclic references</h2>

<p>A need for weak references arises when objects have strong references forming a cycle. In this case, object a has a reference to b and vice versa:</p>

$$code(lang=pycon)
>>> a = Foo()
created
>>> b = Foo()
created
>>> a.store(b)
>>> b.store(a)
>>> del a
>>> del b
$$/code

<p>The destructor methods on a and b are never called and the objects continue to live until the interpreter exits. This example may seem contrived, but it is representative of patterns having a bidirectional relationship. If a parent GUI widget has a reference to a child widget while the child has a reference to its container parent, a cyclic reference exists. A node in a doubly linked list has a cyclic relationship. Even a node in a singly linked list may be part of a cycle that impedes proper object destruction:</p>

$$code(lang=pycon)
>>> a = Foo()
created
>>> b = Foo()
created
>>> c = Foo()
created
>>> a.store(b)
>>> b.store(c)
>>> c.store(a)
>>> del a

>>> del b
>>> del c
$$/code

<p>A solution to this problem is to store weak references:</p>

$$code(lang=python)
class Foo(object): 

    ...

    def show(self):
        print self.obj()

    def store(self, obj):
        self.obj = weakref.ref(obj)
$$/code

<p>With this implementation, the two objects are destroyed when strong references a and b are deleted:</p>

$$code(lang=pycon)
>>> a = Foo()
created
>>> b = Foo()
created
>>> c = Foo()
created
>>> a.store(b)
>>> b.store(c)
>>> c.store(a)
>>> del a
destroyed
>>> del b
destroyed
>>> del c
destroyed
$$/code

<h2>Dead-on-arrival</h2>

<p>The <a href="http://docs.python.org/lib/module-weakref.html">weakref module</a> cannot create weak references to all objects. For instance, passing a Python list, tuple, dictionary, numeric, string, or None will raise a TypeError exception. This limitation and response is reasonable. However, sometimes creation of a weak references fails silently:</p>

$$code(lang=pycon)
>>> a = Foo()
created
>>> b = Foo()
created
>>> a.store(b.show) # store creates a weak reference
>>> a.show()
None
$$/code

<p>Shouldn't the variable a hold a reference to the bound method show on the instance in b? No. The reason for this seemingly strange behavior is that bound methods are created on demand when accessed on an instance. In this code, the bound method b.show is created and passed to the method Foo.store. This method stores a weak reference to b.show in the instance variable a.obj. Once the store method ends, there is no longer a strong reference to the bound method b.show and so it is immediately destroyed. In a sense, the weak reference in a.obj is dead-on-arrival.</p>

<h2>Extending weak references</h2>

<p>Even though the <a href="http://docs.python.org/lib/module-weakref.html">weakref module</a> cannot create weak references to bound methods, you can create a weak reference proxy class that works for bound methods as well as other objects. The following code from the <a href="http://live.gnome.org/LSR">Linux Screen Reader</a> project accomplishes exactly this goal. When a bound method is passed to the constructor of the Proxy class, it creates a weak reference to the instance and strong references to its class and function definition. Later, when the method is called, it creates a strong method just in time. For all other objects, it acts just like weakref.proxy:</p>

$$code(lang=python)
import weakref, new 

class Proxy(object):
  '''
  Our own proxy object which enables weak references to bound and unbound
  methods and arbitrary callables. Pulls information about the function,
  class, and instance out of a bound method. Stores a weak reference to the
  instance to support garbage collection.

  @organization: IBM Corporation
  @copyright: Copyright (c) 2005, 2006 IBM Corporation
  @license: The BSD License
  '''
  def __init__(self, cb):
    try:
      try:
        self.inst = weakref.ref(cb.im_self)
      except TypeError:
        self.inst = None
      self.func = cb.im_func
      self.klass = cb.im_class
    except AttributeError:
      self.inst = None
      self.func = cb.im_func
      self.klass = None

  def __call__(self, *args, **kwargs):
    '''
    Proxy for a call to the weak referenced object. Take arbitrary params to
    pass to the callable.

    @raise ReferenceError: When the weak reference refers to a dead object
    '''
    if self.inst is not None and self.inst() is None:
      raise ReferenceError
    elif self.inst is not None:
      # build a new instance method with a strong reference to the instance
      mtd = new.instancemethod(self.func, self.inst(), self.klass)
    else:
      # not a bound method, just return the func
      mtd = self.func
    # invoke the callable and return the result
    return mtd(*args, **kwargs)

  def __eq__(self, other):
    '''
    Compare the held function and instance with that held by another proxy.

    @param other: Another proxy object
    @type other: L{Proxy}
    @return: Whether this func/inst pair is equal to the one in the other
    proxy object or not
    @rtype: boolean
    '''
    try:
      return self.func == other.func and self.inst() == other.inst()
    except Exception:
      return False

  def __ne__(self, other):
    '''
    Inverse of __eq__.
    '''
    return not self.__eq__(other)
$$/code
