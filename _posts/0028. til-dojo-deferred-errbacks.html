---
date: 2011/02/06 13:24:09
permalink: http://mindtrove.info/til-dojo-deferred-errbacks/
tags: dojo, commonjs, deferred, promise, error
title: 'TIL: Error callbacks in dojo.Deferred chains'
---

<p><a href="http://www.sitepen.com/blog/2010/05/03/robust-promises-with-dojo-deferred-1-5/">Starting in 1.5</a>, Dojo's <a href="http://dojotoolkit.org/api/1.5/dojo/Deferred">Deferred class</a> exposes a <tt>then()</tt> method that accepting three arguments: a success handler for <tt>callback()</tt>, an error handler for <tt>errback</tt>, and a progress handler for <tt>progress()</tt> updates. One interesting feature of the <tt>dojo.Deferred</tt> implementation is the ability of a callback handler to return a new deferred which becomes the target of the next handler scheduled on the original deferred.</p>

<p>Consider these two snippets. The first shows chaining on a single deferred. The second shows chaining switching to a new deferred.</p>

$$code(lang=javascript)
var d = functionReturningADeferred();
d.then(function() {
    console.log('first success');
}).then(function() {
    // scheduled on the same deferred as the first
    // runs immediately after the first callback handler
    console.log('second success');
});

var d = functionReturningADeferred();
d.then(function() {
    console.log('first success');
    return anotherDeferredReturningFunction();
}).then(function() {
    // scheduled on deferred from anotherDeferredReturningFunction
    // runs when the second deferred's callback is invoked
    console.log('second success');
});
$$/code

<h2>Error handlers everywhere</h2>
<p>I recently wrote some code where my callbacks returned new deferreds for chaining, but any deferred in the chain might have its <tt>errback</tt> invoked due to an error. I wanted my handler chain to cease firing after the first occurrence of an error with only one handler invoked for that error. I naively started with the following recipe:</p>

$$code(lang=javascript)
var d = functionReturningADeferred();
d.then(function() {
    console.log('first success');
    return anotherDeferredReturningFunction();
}, function() {
    console.log('first error');
}).then(function() {
    console.log('second success');
    return yetAnotherDeferredReturningFunction();
}, function() {
    console.log('second error');
}).then(function() {
    console.log('third success');
}, function() {
    console.log('third error');
});
$$/code

<p>To my surprise, when the very first deferred's <tt>errback()</tt> was invoked, the console output declared:</p>

<pre>
  first error
  second success
  third success
</pre>

<p>Likewise, when the second deferred's <tt>errback</tt> was invoked, the console output was:</p>

<pre>
  first success
  second error
  third success
</pre>

<p>The problem with this pattern is that chained calls to <tt>then()</tt> register handlers for the success and failure conditions of the previous handler set when a new deferred is not returned.</p>

<h2>Error handlers throwing errors</h2>

<p>I next tried the following approach:</p>

$$code(lang=javascript)
var d = functionReturningADeferred();
d.then(function() {
    console.log('first success');
    return anotherDeferredReturningFunction();
}, function(err) {
    console.log('first error');
    throw err;
}).then(function() {
    console.log('second success');
    return yetAnotherDeferredReturningFunction();
}, function(err) {
    console.log('second error');
    throw err;
}).then(function() {
    console.log('third success');
}, function(err) {
    console.log('third error');
    throw err;
});
$$/code

<p>This code was an improvement, but did not have the desired behavior. An <tt>errback()</tt> on the initial deferred produced the following output:</p>

<pre>
  first error
  second error
  third error
</pre>

<p>The same problem plaguing the first approach is in effect here: the error handlers do not return deferreds, so all chained <tt>then()</tt> calls operate on the error thrown by their respective predecessors.</p>

<h2>One error handler at the end</h2>

<p>Finally, I hit upon a pattern with the behavior I wanted:</p>

$$code(lang=javascript)
var d = functionReturningADeferred();
d.then(function() {
    console.log('first success');
    return anotherDeferredReturningFunction();
}).then(function() {
    console.log('second success');
    return yetAnotherDeferredReturningFunction();
}).then(function() {
    console.log('third success');
}, function(err) {
    console.log('any error');
});
$$/code

<p>A <tt>errback()</tt> on the first deferred now resulted in the following output:</p>

<pre>
  any error
</pre>

<p>An <tt>errback()</tt> on the second produced in the following:</p>

<pre>
  first success
  any error
</pre>

<p>Any error early in the chain falls through the chain until it reaches an error handler. Placing the error handler at the end of the chain guarantees it and it alone will fire after any <tt>errback()</tt> in the chain.</p>

<h2>Try it yourself</h2>

<p>I created a easy-to-run jsFiddle that demonstrates the second and third patterns mentioned in this post. Let me know if you find any other interesting behaviors.</p>

<iframe style="width: 100%; height: 300px; border: 1px solid gray;" src="http://jsfiddle.net/parente/Azh4t/embedded/"></iframe>