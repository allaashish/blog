---
date: 2011/02/06 13:24:09
permalink: http://mindtrove.info/til-dojo-deferred-errbacks/
tags: javascript, dojo, deferred, promise, error
title: 'TIL: Error handlers in dojo.Deferred chains'
---

<p><a href="http://www.sitepen.com/blog/2010/05/03/robust-promises-with-dojo-deferred-1-5/">Starting in 1.5</a>, Dojo's <a href="http://dojotoolkit.org/api/1.5/dojo/Deferred">Deferred class</a> exposes a <tt>then()</tt> method that accepting three arguments: a success handler for <tt>callback()</tt>, an error handler for <tt>errback</tt>, and a progress handler for <tt>progress()</tt> updates. One interesting feature of the <tt>dojo.Deferred</tt> implementation is the ability of a callback handler to return a new deferred which becomes the target of the next handler scheduled on the original deferred.</p>

<p>Consider these two snippets. The first shows chaining on a single deferred. The second shows chaining with a new deferred returned within the chain.</p>

$$code(lang=javascript)
var d1 = functionReturningADeferred();
d1.then(function() {
    console.log('first success');
}).then(function() {
    // scheduled on the same deferred as the first
    // runs if the first handler completes without an exception
    console.log('second success');
});

var d2 = functionReturningADeferred();
d2.then(function() {
    console.log('first success');
    return anotherDeferredReturningFunction();
}).then(function() {
    // scheduled on deferred from anotherDeferredReturningFunction
    // runs when the second deferred's callback is invoked
    console.log('second success');
});
$$/code

<h2>Try #1: Error handlers everywhere</h2>
<p>I recently wrote some code in which my deferred callback handlers returned new deferreds for chaining, but where any deferred in the chain might have its <tt>errback()</tt> invoked. I wanted my handler chain to cease firing after the first occurrence of an error with one and only one handler invoked for that error. I naively started with the following recipe:</p>

$$code(lang=javascript)
var d = functionReturningADeferred();
d.then(function() {
    console.log('first success');
    return anotherDeferredReturningFunction();
}, function() {
    console.log('first error');
}).then(function() {
    console.log('second success');
    return yetAnotherDeferredReturningFunction();
}, function() {
    console.log('second error');
}).then(function() {
    console.log('third success');
}, function() {
    console.log('third error');
});
$$/code

<p>To my surprise, when the very first deferred's <tt>errback()</tt> was invoked, the console output declared:</p>

<pre>
  first error
  second success
  third success
</pre>

<p>Likewise, when the second deferred's <tt>errback</tt> was invoked, the console output was:</p>

<pre>
  first success
  second error
  third success
</pre>

<p>I quickly realized my mistake: my error handlers did not return new deferreds. Therefore, each additional <tt>then()</tt> call in my chain registered handlers to be invoked by the success or failure of the previous set in the chain.</p>

<h2>Try #2: Error handlers throwing errors</h2>

<p>I next tried the following approach:</p>

$$code(lang=javascript)
var d = functionReturningADeferred();
d.then(function() {
    console.log('first success');
    return anotherDeferredReturningFunction();
}, function(err) {
    console.log('first error');
    throw err;
}).then(function() {
    console.log('second success');
    return yetAnotherDeferredReturningFunction();
}, function(err) {
    console.log('second error');
    throw err;
}).then(function() {
    console.log('third success');
}, function(err) {
    console.log('third error');
    throw err;
});
$$/code

<p>This code showed improvement, but still did not have my desired behavior. An <tt>errback()</tt> on the initial deferred produced the following output:</p>

<pre>
  first error
  second error
  third error
</pre>

<p>An <tt>errback()</tt> on the second showed the following output:</p>

<pre>
  first success
  second error
  third error
</pre>

<p>After a little more thinking, I realized the same problem plaguing my first approach was in effect here. My error handlers were still not returning new deferreds. The chained handlers were still operating on the success or failure conditions of their predecessors.</p>

<h2>Solution: One terminal error handler</h2>

<p>Finally, I hit upon a pattern with the behavior I wanted:</p>

$$code(lang=javascript)
var d = functionReturningADeferred();
d.then(function() {
    console.log('first success');
    return anotherDeferredReturningFunction();
}).then(function() {
    console.log('second success');
    return yetAnotherDeferredReturningFunction();
}).then(function() {
    console.log('third success');
}, function(err) {
    console.log('any error');
});
$$/code

<p>A <tt>errback()</tt> on the first deferred now resulted in the following output:</p>

<pre>
  any error
</pre>

<p>An <tt>errback()</tt> on the second produced in the following:</p>

<pre>
  first success
  any error
</pre>

<h3>Why does it work?</h3>

<p>Any error early in the chain falls through the chain until it reaches an error handler. Placing the error handler at the end of the chain guarantees it and it alone will fire after any <tt>errback()</tt> in the chain.</p>

<h2>Try it yourself</h2>

<p>I created a easy-to-run jsFiddle that demonstrates the second and third patterns mentioned in this post. Let me know if you find any other interesting behaviors.</p>

<iframe style="width: 100%; height: 300px; border: 1px solid gray; margin-top: 1em" src="http://jsfiddle.net/parente/Azh4t/embedded/"></iframe>